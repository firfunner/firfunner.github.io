# Shell健壮性的一些建议

如果秉承着能跑就行的态度写shell脚本，是很自在的，但是如果你想要写出健壮，可靠的shell脚本，可没那么容易。那么有什么可操作的经验或者方法吗？

而为了保证脚本健壮可靠，那么就需要保证脚本在一些特殊的情况及早出现，避免漏网之鱼。来看看有哪些可行的技巧。

### 脚本失败时即退出

可以在脚本的开头设置如下：

````bash
set -e
````

举个例子：

````bash
#！/bin/bash
set -e
lp    #这里运行会出错
date
````

这种情况下，运行一旦出错就会退出，不放过一个问题：

````bash
$ ./test.sh
lp: Error - no default destination available.
````

当然了，这也有不好的地方，有时候命令执行本来就可能是失败的，你还是希望它继续，可以临时加上``|| true``：

````bash
#！/bin/bash
set -e
lp  || true  
date
````

不过个人觉得这样的设置用处不是特别大，因为很多时候就是需要处理不同的错误情况，而这样只能要么遇到错误退出，要么认为正确，导致无法走到异常分支。
通过``set +e``设置回来：

````bash
set -e
#command
set +e
#other command
````

### 打印脚本执行过程

调试阶段，你可能想知道整个过程是执行了哪些命令，每条命令都具体执行了什么，可以利用下面的方式执行：

````bash
sh -x test.sh
````

或者，和上面类似，在开头加上``set -x``：

````bash
#！/bin/bash
set -x
if [ $# -lt 1 ]
then
   echo  "no para"
else
   echo "para 1 $1"
fi
````

执行时，输出如下：

````bash
+ [ 0 -le 1 ]
+ echo no para
no para
````

前面带+的内容就是命令实际执行的，你可以看到比较条件是什么，变量被展开成了具体内容，走到了哪个分支，非常清楚。

### 显示未定义的变量

shell中变量没有定义，仍然是可以使用的，但是它的结果可能不是你所预期的。举个例子：

````bash
#！/bin/bash
if [ "$var" = "abc" ]
then
   echo  " not abc"
else
   echo " abc "
fi
````

这里本来想判断**var**的内容是否为**abc**，实际上**var**并没有定义，但是在这里使用并没有报错，如果我们想早点发现这类问题，避免在复杂的脚本中问题被掩盖，那么可以在开头加上：``set -u``

再次运行就会提示：

````bash
test.sh: 3: test.sh: num: parameter not set
````

再想象一下，你本来想删除：``rm -rf $dir/*``

然后dir是空的时候，变成了什么？是不是有种后背发凉的感觉？ 

### 管道命令一个失败时整个失败

有时候我们可能会执行类似这样的命令：

````bash
cat test.sh |grep if | cut -d ';' -f 2
````

三条命令一行执行，如果我们希望在其中一条失败，整个命令就失败，而避免执行后面无意义的命令，那么可以在开始设置：

````bash
set -o pipefail
````

不设置的情况下，cat test.sh即使执行失败了，后面的grep实际上还会继续执行，可能会导致一些意想不到的情况发生，如果不想这样的情况发生，那么这样设置是有帮助的。

### 对于静态变量使用readonly

通常我们会在脚本开头定义一些静态变量：``MY_PATH=/usr/bin``

而为了避免MY_PATH被意外修改，可以这样：``readonly MY_PATH=/usr/bin``

这样的话，一旦后面有命令尝试修改，就会报错。

````bash
#!/bin/bash
readonly MY_PATH=/usr/bin
MY_PATH=/usr/local/bin
````

运行一下试试：

````bash
$ sh test.sh
test.sh: 3: test.sh: MY_PATH: is read only
````

看，给你提示了！

### 给变量设置可选的初始值

例如：

````bash
name=${1:-shouwang}
echo "${name}"
````

这里让name为$1，即第一个参数，而当它为空时，另**name**为**shouwang**。

### 多条命令执行使用&&

例如：``cmd0;cmd1;cmd1``

这里如果cmd0失败了，后面的命令仍然会执行，而如果不希望后面的命令执行，可以使用：``cmd0 && cmd1 && cmd1``

### 使用函数

脚本本身比较短还好，而脚本一旦变长，不使用函数，将使得脚本很难维护，可读性也很差。

### 总结

实际上最开始介绍的脚本检查工具就已经非常有效了，基本的错误都能检查出来，而其他的内容，更多的是关注于脚本调试，不放过任何一个可能的错误。

最后，还是优先推荐shellcheck工具。
